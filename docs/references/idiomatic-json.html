<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Copyright © 2013-2020 Metreeca srl. All rights reserved.

  This file is part of Metreeca/Link.

  Metreeca/Link is free software: you can redistribute it and/or modify it under the terms
  of the GNU Affero General Public License as published by the Free Software Foundation,
  either version 3 of the License, or(at your option) any later version.

  Metreeca/Link is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License along with Metreeca/Link.
  If not, see <http://www.gnu.org/licenses/>.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

<!DOCTYPE html>
<html lang="en">
	<head><title>Idiomatic RDF/JSON Serialization Reference | Metreeca Linked Data Framework</title>
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<link rel="shortcut icon" href="../index.svg">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.21.0/themes/prism.min.css">
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.21.0/components/prism-core.min.js"></script>
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.21.0/plugins/autoloader/prism-autoloader.min.js"></script>
		<link rel="stylesheet" type="text/css" href="../index.css">
	</head>
	<body><input id="toggle" type="checkbox">
		<nav>
			<header>
				<span><a href="https://www.metreeca.com/">metreeca</a><a href="../index.html">link<span>v0.53.0</span></a></span><label for="toggle"></label>
			</header>
			<section><a class="title" onclick="document.querySelector('main').scrollTo(0, 0)">Idiomatic RDF/JSON
				Serialization Reference</a><h1><a href="#json-serialization">JSON Serialization</a></h1><h2>
				<a href="#top-level-object">Top-Level Object</a></h2><h2><a href="#rdf-terms">RDF Terms</a></h2><h2>
				<a href="#blank-nodes">Blank Nodes</a></h2><h3><a href="#back-links">Back-Links</a></h3><h2>
				<a href="#iri-references">IRI References</a></h2><h3><a href="#back-links-1">Back-Links</a></h3><h3>
				<a href="#parsing">Parsing</a></h3><h3><a href="#writing">Writing</a></h3><h2><a href="#term-properties">Term
				Properties</a></h2></section>
		</nav>
		<main>
			<header>Idiomatic RDF/JSON Serialization Reference</header>
			<section><p>Beside the standardized <a href="https://www.w3.org/TR/json-ld/" target="_blank">JSON-LD</a> RDF
				serialization, the framework supports a simpler idiomatic JSON‑based format, which streamlines resource
				descriptions taking into account the constraints specified by a target linked data
				<a href="spec-language#shapes">shape</a>.</p>
				<p>Codecs for this serialization make heavy use of reasoning over linked data shapes to
					<strong>prove</strong> useful features of the RDF payload, like the expected value for a property
					being a IRI reference or a required non-repeatable string.</p>
				<p class="note">This serialization format is intended to simplify front-end development by converting RDF
					descriptions to/from idiomatic JSON objects structured according to the conventions a JavaScript
					developer would expect from a typical REST/JSON API. Unlike JSON-LD, it doesn't cater to roundtrip
					de/serialization of RDF payloads without access to the target shape.</p>
				# RDF4J Codecs
				<p>The RDF/SPARQL <a href="../javadocs/com/metreeca/rdf/package-summary.html">adapter</a> automatically
					<a href="http://docs.rdf4j.org/javadoc/latest/org/eclipse/rdf4j/common/lang/service/ServiceRegistry.html" target="_blank">registers</a>
					idiomatic JSON codecs with the RDF4J framework, using the <code>application/json</code> MIME type and
					the <a href="../javadocs/com/metreeca/rdf/formats/RDFFormat.html#RDFJSONFormat">RDFJSONFormat</a>
					RDF4J
					<a href="http://docs.rdf4j.org/javadoc/latest/org/eclipse/rdf4j/rio/RDFFormat.html" target="_blank">RDF
						format</a>.</p>
				<p>Codec behaviour is controlled through the following RDF4J
					<a href="http://docs.rdf4j.org/javadoc/latest/org/eclipse/rdf4j/rio/RioSetting.html" target="_blank">RioSetting</a>
					configuration properties.</p>
				<table>
					<thead>
						<tr>
							<th>setting</th>
							<th>type</th>
							<th>value</th>
							<th>default</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><a href="../javadocs/com/metreeca/rdf/formats/RDFFormat.html#RioShape">RioShape</a></td>
							<td><a href="../javadocs/com/metreeca/tree/Shape.html">Shape</a></td>
							<td>the target shape for the resources to be de/serialized</td>
							<td><code>null</code> (will be inferred from data)</td>
						</tr>
						<tr>
							<td><a href="../javadocs/com/metreeca/rdf/formats/RDFFormat.html#RioFocus">RioFocus</a></td>
							<td>
								<a href="http://docs.rdf4j.org/javadoc/latest/org/eclipse/rdf4j/model/Resource.html" target="_blank">Resource</a>
							</td>
							<td>the entry point for the de/serializaton process</td>
							<td><code>null</code> (will be inferred from data)</td>
						</tr>
						<tr>
							<td><a href="../javadocs/com/metreeca/rdf/formats/RDFFormat.html#RioContext">RioContext</a>
							</td>
							<td>JsonObject</td>
							<td>a custom JSON-LD context for serialisation</td>
							<td>an empty object</td>
						</tr>
					</tbody>
				</table>
				<h1 id="json-serialization">JSON Serialization</h1>
				<p>JSON objects are deserialized to the corresponding RDF payload performing a depth-first visit of the
					JSON value structure. References to previously visited blank nodes and IRI references are represented
					as simplified <em>back-references</em> to the complete representation, omitting predicate values.</p>
				<h2 id="top-level-object">Top-Level Object</h2>
				<pre><code>&lt;rdf&gt; ::= [&lt;term&gt;(, &lt;term&gt;)*]
</code></pre>
				<p>The top-level object for the JSON serialization is an array containing a JSON value for each subject
					in the RDF payload.</p>
				<pre><code>&lt;rdf&gt; ::= &lt;term&gt;
</code></pre>
				<p>If the payload can proved to always contain a single subject or if it contains a subject equal to the
					<em>focus</em> of the serializing operation, the array is simplified to a single JSON value.</p>
				<h2 id="rdf-terms">RDF Terms</h2>
				<pre><code>&lt;term&gt; ::= &lt;blank&gt; | &lt;reference&gt; | &lt;literal&gt;
</code></pre>
				<p>RDF terms are serialized to different JSON value patterns according to their kind.</p>
				<h2 id="blank-nodes">Blank Nodes</h2>
				<pre><code>&lt;blank&gt; ::= {  &quot;@id&quot; : &quot;_:&lt;id&gt;&quot; (, &lt;property&gt;)* }
</code></pre>
				<p>Blank nodes descriptions are serialized as JSON objects including a JSON field for the node identifier
					and a JSON field for each exposed node property.</p>
				<pre><code>&lt;blank&gt; ::= {  &quot;@id&quot; : &quot;&quot; (, &lt;property&gt;)* }
&lt;blank&gt; ::= { [&lt;property&gt; (, &lt;property&gt;)*] }
</code></pre>
				<p>If there is no back-reference from a nested object, the <code>@id</code> id field may be left empty or
					omitted.</p>
				<h3 id="back-links">Back-Links</h3>
				<pre><code>&lt;blank&gt; ::= { &quot;@id&quot;: &quot;_:&lt;id&gt;&quot; }
</code></pre>
				<p>If the term is a back-link to an enclosing blank node, only the <code>@id</code> id field is included.
				</p>
				<pre><code>&lt;blank&gt; ::= &quot;_:&lt;id&gt;&quot;
</code></pre>
				<p>If the term may be proved to be a back-reference to an enclosing resource, the node id may be
					inlined.</p>
				<h2 id="iri-references">IRI References</h2>
				<pre><code>&lt;iri&gt; ::= { &quot;@id&quot; : &quot;&lt;iri&gt;&quot; (, &lt;property&gt;)* }
</code></pre>
				<p>IRI reference descriptions are serialized as JSON objects including a JSON field for the term IRI and
					a JSON field for each exposed term property.</p>
				<pre><code>&lt;iri&gt; ::= { [&lt;property&gt; (, &lt;property&gt;)*] }
</code></pre>
				<p>If the term may be proved to be a constant known IRI reference, the <code>@id</code> id field may be
					omitted.</p>
				<pre><code>&lt;iri&gt; ::= &quot;&lt;iri&gt;&quot;
</code></pre>
				<p>If the term may be proved to be an IRI reference without properties, the IRI may be inlined.</p>
				<h3 id="back-links-1">Back-Links</h3>
				<pre><code>&lt;iri&gt; ::= { &quot;@id&quot;: &quot;&lt;iri&gt;&quot; }
</code></pre>
				<p>If the term is a back-reference to an enclosing object, only the <code>@id</code> id field is
					included.</p>
				<pre><code>&lt;iri&gt; ::= &quot;&lt;iri&gt;&quot;
</code></pre>
				<p>If the term may be proved to be a back-reference to an enclosing resource, the IRI may be inlined.</p>
				<h3 id="parsing">Parsing</h3>
				<p>When parsing, relative <code>&lt;iri&gt;</code> references are resolved against the base URI provided
					to the <a href="../javadocs/com/metreeca/rdf/formats/RDFJSONParser.html">parser</a>, which for HTTP
					REST operations equals the IRI of the request
					<a href="../javadocs/com/metreeca/rest/Request.html#item--">item</a>.</p>
				<h3 id="writing">Writing</h3>
				<p>When writing, local <code>&lt;iri&gt;</code> references are relativized as root-relative IRIs against
					the base URI provided to the
					<a href="../javadocs/com/metreeca/rdf/formats/RDFJSONWRiter.html">writer</a>, which for HTTP REST
					operations equals the root IRI of the response
					<a href="../javadocs/com/metreeca/rest/Response.html#item--">item</a>.</p>
				<h2 id="term-properties">Term Properties</h2>
				<pre><code>&lt;property&gt; ::= &lt;path&gt;: [&lt;term&gt;(, &lt;term&gt;)*]
</code></pre>
				<p>Direct/inverse RDF property values are serialized as JSON object fields including the property path as
					label and a JSON array containing serialized property objects/subjects as value.</p>
				<p>If a target shape is provided to the codec, only direct/inverse properties specified in the shape are
					included in the description; otherwise, only direct properties are included.</p>
				<pre><code>&lt;property&gt; ::= &lt;path&gt;: &lt;term&gt;
</code></pre>
				<p>If the property value may be proved to be non-repeatable, it may be included as a single JSON value,
					rather than a JSON array.</p>
				<pre><code>&lt;path&gt; ::= &quot;&lt;&lt;iri&gt;&gt;&quot; | &quot;^&lt;&lt;iri&gt;&gt;&quot; | &quot;&lt;iri&gt;&quot; | &quot;^&lt;iri&gt;&quot; | &quot;&lt;alias&gt;&quot;
</code></pre>
				<p>Predicate IRIs are represented as strings, in either plain or angle bracket notation. Predicate IRIs
					for inverse RDF properties are prefixed with a caret charatecter (<code>^</code>).</p>
				<p>If a shape is provided to the codec, predicate IRIs are reported in a shortened form using
					user-defined or system-inferred <a href="spec-language#annotations">aliases</a>. Predicate IRIs with
					clashing aliases are written in full using the angle bracket notation.</p>
				<p class="warning"><code>@id</code> and <code>_type</code> properties are reserved for system use.</p>
				## Literals
				<pre><code>&quot;&lt;text&gt;&quot;^^&lt;type&gt; ::= { &quot;@value&quot;: &quot;&lt;text&gt;&quot;, &quot;@type&quot;: &quot;&lt;type&gt;&quot; }
&quot;&lt;text&gt;&quot;@&lt;lang&gt;  ::= { &quot;@value&quot;: &quot;&lt;text&gt;&quot;, &quot;@language&quot;: &quot;&lt;lang&gt;&quot; }
</code></pre>
				<p>In the more general form, literals are serialized as JSON objects including the literal lexical
					representation and either the literal datatype IRI or the literal language tag.</p>
				<pre><code>&quot;&lt;text&gt;&quot;             ::= &quot;&lt;text&gt;&quot;
&quot;&lt;text&gt;&quot;^^xsd:string ::= &quot;&lt;text&gt;
</code></pre>
				<p>Simple literals and typed <code>xsd:string</code> literals are serialized as JSON string values.</p>
				<pre><code>&quot;&lt;integer&gt;&quot;^^xsd:integer ::= &lt;integer&gt; # no decimal part
&quot;&lt;decimal&gt;&quot;^^xsd:decimal ::= &lt;decimal&gt; # decimal part

&quot;&lt;number&gt;&quot;^^&lt;type&gt; ::= { &quot;@value&quot;: &quot;&lt;number&gt;&quot;, &quot;@type&quot;: &quot;&lt;type&gt;&quot; } # explicit type
</code></pre>
				<p>Typed <code>xsd:integer</code> and <code>xsd:decimal</code> literals are serialized as JSON numeric
					values using type-specific number formats. Other typed numeric literals are serialized in the
					extended form.</p>
				<pre><code>&quot;boolean&quot;^^xsd:boolean ::= &lt;boolean&gt;
</code></pre>
				<p>Typed <code>xsd:boolean</code> literals are serialized as JSON boolean values.</p>
				<pre><code>&quot;&lt;text&gt;&quot;^^&lt;type&gt; ::= &quot;&lt;text&gt;&quot;
</code></pre>
				<p>If the datatype of the literal may be proved to be a constant known value, the literal may be
					serialized as a JSON string value including its lexical representation, omitting datatype info.</p>
			</section>
			<footer>© 2020 Metreeca srl. This work is licensed under the
				<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons BY-NC-SA 4.0 License</a>
			</footer>
		</main>
		<script type="text/javascript" src="../index.js"></script>
	</body>
</html>