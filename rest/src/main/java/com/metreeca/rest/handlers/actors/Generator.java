/*
 * Copyright Â© 2013-2019 Metreeca srl. All rights reserved.
 *
 * This file is part of Metreeca.
 *
 * Metreeca is free software: you can redistribute it and/or modify it under the terms
 * of the GNU Affero General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or(at your option) any later version.
 *
 * Metreeca is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License along with Metreeca.
 * If not, see <http://www.gnu.org/licenses/>.
 */

package com.metreeca.rest.handlers.actors;


import com.metreeca.form.Form;
import com.metreeca.rest.*;
import com.metreeca.rest.bodies.RDFBody;
import com.metreeca.rest.handlers.Delegator;
import com.metreeca.rest.wrappers.Connector;
import com.metreeca.rest.wrappers.Throttler;

import org.eclipse.rdf4j.model.Model;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.impl.LinkedHashModel;

import java.util.Collection;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;

import static com.metreeca.rest.Wrapper.wrapper;
import static com.metreeca.rest.bodies.RDFBody.rdf;


/**
 * Virtual resource generator.
 *
 * <p>Handles retrieval requests on the virtual linked data resource identified by the request {@linkplain
 * Request#item() focus item}.</p>
 *
 * <p>The response {@linkplain RDFBody RDF body} includes the description of the request target as generated by the
 * {@linkplain #Generator(BiFunction) virtual model generator}.</p>
 *
 * <p>Empty generated models are reported with a {@link Response#NotFound} status code.</p>
 *
 * <p>If the request includes a shape, the response includes also the derived shape actually used in the resource
 * generation process, redacted according to request user {@linkplain Request#roles() roles}, {@link Form#relate} task,
 * {@link Form#convey} mode and {@link Form#detail} view.</p>
 */
public final class Generator extends Delegator {

	private final BiFunction<Request, Model, Model> generator;


	/**
	 * Creates a virtual model generator.
	 *
	 * @param generator a function mapping from a request and its {@linkplain RDFBody RDF} payload to a possibly empty
	 *                  RDF model; must return a non null value; generators based on SPARQL graph queries may be created
	 *                  using {@link Connector} factory methods
	 *
	 * @throws NullPointerException if {@code generator} is null
	 * @see Connector#query(String, BiConsumer[])
	 */
	public Generator(final BiFunction<Request, Model, Model> generator) {

		if ( generator == null ) {
			throw new NullPointerException("null generator");
		}

		this.generator=generator;

		delegate(generator().with(annotator()).with(throttler()));
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	private Wrapper annotator() {
		return handler -> request -> handler.handle(request).map(response ->
				response.header("+Vary", "Accept")
		);
	}

	private Wrapper throttler() {
		return wrapper(Request::container,
				new Throttler(Form.relate, Form.digest, Throttler::entity),
				new Throttler(Form.relate, Form.detail, Throttler::resource)
		);
	}

	private Handler generator() {
		return request -> request.reply(response -> {
			if ( request.query().isEmpty() ) {

				return request.body(rdf()).fold(

						model -> {

							final Collection<Statement> virtual=Objects.requireNonNull(
									generator.apply(request, new LinkedHashModel(model)),
									"null generator return value"
							);

							return virtual.isEmpty() ? response.status(Response.NotFound) : response

									.status(Response.OK)
									.shape(request.shape())
									.body(rdf(), virtual);

						},

						response::map

				);

			} else { // !!! handle queries

				return response.map(new Failure()
						.status(Response.BadRequest)
						.cause("queries not supported on virtual resources")
				);

			}

		});
	}

}
